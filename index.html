<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>QAM Virtual Laboratory ‚Äî Full Simulation</title>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<!-- FontAwesome for icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="./qam.css">
<script src="./qam.js" defer></script>

<!-- Link project stylesheet so lab.css overrides inline rules -->

</head>
<body>
<div class="container">
  <div class="header">
    <img src="https://ptuniv.edu.in/assets/images/ptu-logo.png" alt="PTU Logo" style="height: 60px; margin-right: 1rem; float: left;">
    <h1>QAM Virtual Laboratory</h1>
<p>
A virtual laboratory experiment for studying Quadrature Amplitude Modulation (QAM),
focusing on constellation behavior, time-domain waveforms, and BER/SER performance over AWGN channels.
</p>
  </div>

  <div class="nav" role="tablist" aria-label="Sections">
    <button type="button" class="nav-btn active" data-page="aim">Aim</button>
    <button type="button" class="nav-btn" data-page="theory">Theory</button>
    <button type="button" class="nav-btn" data-page="procedure">Procedure</button>
    <button type="button" class="nav-btn" data-page="pretest">Pre-Test</button>
     
    <button type="button" class="nav-btn" data-page="simulation">Simulation</button>
    <button type="button" class="nav-btn" data-page="posttest">Post-Test</button>
    <!-- FAQ removed per user request -->
    <button type="button" class="nav-btn" data-page="results">Results</button>
  </div>

  <!-- HELP BUTTON -->
  <button id="helpBtn" class="help-btn">
      <i class="fas fa-lightbulb"></i> HELP
  </button>

  <!-- REFERENCE CONTAINER -->
  <div id="helpContainer" class="help-container hidden">
      <div class="help-card">
          
          <!-- HEADER -->
          <div class="help-header">
              <h2>Help & Reference</h2>
              <span id="closeHelp" class="close-btn">&times;</span>
          </div>

          <!-- FLASHCARDS GRID -->
          <div class="card-grid">
              
              <div class="flashcard">
                  <span class="label">Frequency Range</span>
                  <span class="value">1Hz ‚Äì 10kHz</span>
              </div>

              <div class="flashcard">
                  <span class="label">Amplitude</span>
                  <span class="value">1V ‚Äì 10V</span>
              </div>

              <div class="flashcard">
                  <span class="label">Time/Div</span>
                  <span class="value">0.1ms ‚Äì 10ms</span>
              </div>

              <div class="flashcard">
                  <span class="label">Volt/Div</span>
                  <span class="value">1V ‚Äì 5V</span>
              </div>

              <div class="flashcard">
                  <span class="label">Example Input</span>
                  <span class="value">f=1kHz, A=5V</span>
              </div>

          </div>
      </div>
  </div>

  <!-- AIM -->
  <section id="aim" class="page active" role="region" aria-labelledby="aim">
    <h2> Aim</h2>
<p>
To study Quadrature Amplitude Modulation (QAM) by visualizing
constellation diagrams, time-domain waveforms, and evaluating Bit Error Rate (BER)
and Symbol Error Rate (SER) performance over an Additive White Gaussian Noise (AWGN) channel.
</p>
    <p style="margin-top:8px;">
      This laboratory aims to:
    </p>
    <ul style="margin:8px 0 0 18px;">
      <li>Demonstrate how digital bits are mapped to complex symbols (I/Q) in various M-QAM constellations.</li>
      <li>Visualize the effect of additive white Gaussian noise (AWGN) on constellation clustering and on symbol/bit errors.</li>
      <li>Provide hands-on controls to vary SNR, symbol rate, carrier frequency and input patterns to see their practical impact.</li>
      <li>Enable comparison between theoretical expectations and observed BER/SER through reproducible simulations.</li>
    </ul>
  </section>

  <!-- THEORY -->
  <section id="theory" class="page" role="region" aria-labelledby="theory">
    <h2> Theory</h2>

    <h3>1. Introduction to Quadrature Amplitude Modulation</h3>
    <p>
      <keyword>Quadrature Amplitude Modulation</keyword> (QAM) is a sophisticated modulation scheme that communicates data by changing (modulating) the amplitudes of two carrier waves. These two waves, usually sinusoids, are out of phase with each other by 90¬∞ and are thus called <keyword>quadrature</keyword> components. QAM is widely used in modern digital telecommunications, including Wi‚ÄëFi, cellular networks (LTE/5G), and cable modems, due to its high <keyword>spectral efficiency</keyword>.
    </p>

    <h3>2. Mathematical Representation</h3>
    <p>
      A QAM signal can be expressed as a linear combination of two orthogonal basis functions:
      <code>œÜ‚ÇÅ(t) = ‚àö(2/T‚Çõ) cos(2œÄ f_c t)</code> and
      <code>œÜ‚ÇÇ(t) = ‚àö(2/T‚Çõ) sin(2œÄ f_c t)</code>.
      The general form of the transmitted signal <code>s(t)</code> is:
    </p>
    <pre>
      s(t) = A_i cos(2œÄ f_c t + Œ∏_i)
           = I_n cos(2œÄ f_c t) - Q_n sin(2œÄ f_c t)
    </pre>
    <p>
      Where:
      <ul style="margin:4px 0 0 18px;">
        <li><code>I_n</code> is the <keyword>In-phase</keyword> component.</li>
        <li><code>Q_n</code> is the <keyword>Quadrature</keyword> component.</li>
        <li><code>f_c</code> is the carrier frequency.</li>
        <li><code>T‚Çõ</code> is the symbol duration.</li>
      </ul>
    </p>
    <p>
      For an <em>M</em>-ary QAM system, the number of bits per symbol <code>k</code> is given by:
    </p>
    <pre>
      k = log‚ÇÇ(M)
    </pre>
    <p>
      For example, in 16‚ÄëQAM each symbol represents 4 bits, while in 64‚ÄëQAM each symbol represents 6 bits.
    </p>

    <h3>3. Block Diagram</h3>
    <p>
      The implementation of QAM requires precise phase synchronization between the transmitter and the receiver.
    </p>
    <!-- inserted photo of QAM transmitter/receiver -->
    <div class="theory-image-container" style="text-align:center; margin:12px 0;">
      <img src="./block-diagram.png" alt="QAM transmitter and receiver block diagram" style="max-width:100%; height:auto;" />
      <div class="small-muted" style="font-size:0.9rem; margin-top:4px;">Figure: Simplified QAM transmitter / receiver block diagram</div>
    </div>
    

    <!-- Begin block diagrams excerpt from separate page -->
    <div class="bd-section">
      <!-- Left: Block diagrams for each modulation -->
      <div class="bd-card">
        <div class="small-title">Block diagrams (simplified & clear)</div>

        <div class="bd-grid" style="margin-top:10px">
          <!-- 4-QAM -->
          <div>
            <div style="font-weight:700;margin-bottom:6px">4-QAM </div>
            <div class="bd-diagram" aria-hidden="true">
              <svg width="320" height="60" viewBox="0 0 320 60" xmlns="http://www.w3.org/2000/svg">
                <rect x="6" y="10" width="64" height="40" rx="6" fill="#fff" stroke="#e6eefc"/>
                <text x="38" y="35" font-size="11" text-anchor="middle" fill="#222">Bit Source</text>
                <rect x="80" y="10" width="64" height="40" rx="6" fill="#fff" stroke="#e6eefc"/>
                <text x="112" y="35" font-size="11" text-anchor="middle" fill="#222">Mapper</text>
                <rect x="154" y="10" width="64" height="40" rx="6" fill="#fff" stroke="#e6eefc"/>
                <text x="186" y="35" font-size="11" text-anchor="middle" fill="#222">I/Q Modulator</text>
                <rect x="228" y="10" width="84" height="40" rx="6" fill="#fff" stroke="#ffeede"/>
                <text x="270" y="35" font-size="11" text-anchor="middle" fill="#222">AWGN Channel</text>
                <line x1="70" y1="30" x2="80" y2="30" stroke="#cbdffd" stroke-width="2"/>
                <line x1="144" y1="30" x2="154" y2="30" stroke="#cbdffd" stroke-width="2"/>
                <line x1="218" y1="30" x2="228" y2="30" stroke="#ffdac6" stroke-width="2"/>
              </svg>
            </div>
            <div style="margin-top:8px;font-size:0.95rem;color:#333">
              <strong>Formula (bits/symbol):</strong> b = log2(4) = 2
              <div><strong>Typical working SNR (approx):</strong> ~8‚Äì12 dB for low BER (depends on target)</div>
            </div>
          </div>

          <!-- 16-QAM -->
          <div>
            <div style="font-weight:700;margin-bottom:6px">16-QAM</div>
            <div class="bd-diagram" aria-hidden="true">
              <svg width="320" height="60" viewBox="0 0 320 60" xmlns="http://www.w3.org/2000/svg">
                <rect x="6" y="10" width="64" height="40" rx="6" fill="#fff" stroke="#e6eefc"/>
                <text x="38" y="35" font-size="11" text-anchor="middle" fill="#222">Source</text>
                <rect x="80" y="10" width="64" height="40" rx="6" fill="#fff" stroke="#e6eefc"/>
                <text x="112" y="35" font-size="11" text-anchor="middle" fill="#222">Gray Mapper</text>
                <rect x="154" y="10" width="64" height="40" rx="6" fill="#fff" stroke="#e6eefc"/>
                <text x="186" y="35" font-size="11" text-anchor="middle" fill="#222">Pulse Shaper</text>
                <rect x="228" y="10" width="84" height="40" rx="6" fill="#fff" stroke="#ffeede"/>
                <text x="270" y="35" font-size="11" text-anchor="middle" fill="#222">RF & Channel</text>
                <line x1="70" y1="30" x2="80" y2="30" stroke="#cbdffd" stroke-width="2"/>
                <line x1="144" y1="30" x2="154" y2="30" stroke="#cbdffd" stroke-width="2"/>
                <line x1="218" y1="30" x2="228" y2="30" stroke="#ffdac6" stroke-width="2"/>
              </svg>
            </div>
            <div style="margin-top:8px;font-size:0.95rem;color:#333">
              <strong>Formula (bits/symbol):</strong> b = log2(16) = 4
              <div><strong>Typical working SNR (approx):</strong> ~16‚Äì22 dB for practical low BER</div>
            </div>
          </div>

          <!-- 64-QAM -->
          <div>
            <div style="font-weight:700;margin-bottom:6px">64-QAM</div>
            <div class="bd-diagram" aria-hidden="true">
              <svg width="320" height="60" viewBox="0 0 320 60" xmlns="http://www.w3.org/2000/svg">
                <rect x="6" y="10" width="64" height="40" rx="6" fill="#fff" stroke="#e6eefc"/>
                <text x="38" y="35" font-size="11" text-anchor="middle" fill="#222">Source</text>
                <rect x="80" y="10" width="64" height="40" rx="6" fill="#fff" stroke="#e6eefc"/>
                <text x="112" y="35" font-size="11" text-anchor="middle" fill="#222">Encoder / Mapper</text>
                <rect x="154" y="10" width="64" height="40" rx="6" fill="#fff" stroke="#e6eefc"/>
                <text x="186" y="35" font-size="11" text-anchor="middle" fill="#222">Matched Filter</text>
                <rect x="228" y="10" width="84" height="40" rx="6" fill="#fff" stroke="#ffeede"/>
                <text x="270" y="35" font-size="11" text-anchor="middle" fill="#222">RF & Channel</text>
                <line x1="70" y1="30" x2="80" y2="30" stroke="#cbdffd" stroke-width="2"/>
                <line x1="144" y1="30" x2="154" y2="30" stroke="#cbdffd" stroke-width="2"/>
                <line x1="218" y1="30" x2="228" y2="30" stroke="#ffdac6" stroke-width="2"/>
              </svg>
            </div>
            <div style="margin-top:8px;font-size:0.95rem;color:#333">
              <strong>Formula (bits/symbol):</strong> b = log2(64) = 6
              <div><strong>Typical working SNR (approx):</strong> ~22‚Äì28 dB for low BER in many systems</div>
            </div>
          </div>

          <!-- 256-QAM -->
          <div>
            <div style="font-weight:700;margin-bottom:6px">256-QAM</div>
            <div class="bd-diagram" aria-hidden="true">
              <svg width="320" height="60" viewBox="0 0 320 60" xmlns="http://www.w3.org/2000/svg">
                <rect x="6" y="10" width="64" height="40" rx="6" fill="#fff" stroke="#e6eefc"/>
                <text x="38" y="35" font-size="11" text-anchor="middle" fill="#222">Source</text>
                <rect x="80" y="10" width="64" height="40" rx="6" fill="#fff" stroke="#e6eefc"/>
                <text x="112" y="35" font-size="11" text-anchor="middle" fill="#222">FEC / Mapper</text>
                <rect x="154" y="10" width="64" height="40" rx="6" fill="#fff" stroke="#e6eefc"/>
                <text x="186" y="35" font-size="11" text-anchor="middle" fill="#222">Pulse Shaping</text>
                <rect x="228" y="10" width="84" height="40" rx="6" fill="#fff" stroke="#ffeede"/>
                <text x="270" y="35" font-size="11" text-anchor="middle" fill="#222">RF & Channel</text>
                <line x1="70" y1="30" x2="80" y2="30" stroke="#cbdffd" stroke-width="2"/>
                <line x1="144" y1="30" x2="154" y2="30" stroke="#cbdffd" stroke-width="2"/>
                <line x1="218" y1="30" x2="228" y2="30" stroke="#ffdac6" stroke-width="2"/>
              </svg>
            </div>
            <div style="margin-top:8px;font-size:0.95rem;color:#333">
              <strong>Formula (bits/symbol):</strong> b = log2(256) = 8
              <div><strong>Typical working SNR (approx):</strong> ~28‚Äì35 dB (sensitive to impairments and non-linearities)</div>
            </div>
          </div>
        </div>

        <div style="margin-top:12px" class="small-muted">
          <div style="font-weight:700;margin-bottom:6px">
Reference Communication System Block Diagram (Beyond Scope of This Simulation)
</div>
<p class="small-muted">
Note: The current simulation focuses on baseband QAM modulation, AWGN channel,
and nearest-neighbor detection. Advanced blocks shown here (FEC, pulse shaping,
equalization) are part of practical systems and are not implemented in this experiment.
</p>
          <div>
            A concise, practical transmit/receive chain for teaching:
            <pre class="pre-block">
Transmitter:
  Bit Source
    ‚Üì
  FEC Encoder (optional)
    ‚Üì
  Bit Interleaver (optional)
    ‚Üì
  Mapper (Gray mapping recommended)
    ‚Üì
  Pulse Shaping (e.g., root-raised cosine)
    ‚Üì
  I/Q Modulator ‚Üí RF Chain
    ‚Üì
Channel: AWGN (plus fading/impairments as required)

Receiver (reverse):
  RF Front-end ‚Üí Downconversion
    ‚Üì
  Matched Filter / Sampling
    ‚Üì
  Equalization / Synchronization
    ‚Üì
  Demapper ‚Üí Deinterleaver ‚Üí Decoder
            </pre>
          </div>
        </div>
      </div>

      <!-- Right: Applications and extra info -->
      <div class="bd-card">
        <div class="small-title">Top 10 Applications (widely used)</div>
        <ul class="app-list" style="margin-top:8px">
          <li>Digital cable TV (QAM-based cable systems)</li>
          <li>Wi‚ÄëFi (IEEE 802.11ac/ax use 64/256-QAM)</li>
          <li>Cellular downlink (LTE, 4G/5G adaptive QAM)</li>
          <li>DSL technologies (e.g., VDSL)</li>
          <li>Satellite broadband links</li>
          <li>Microwave backhaul & point-to-point radios</li>
          <li>Optical coherent communications (higher-order QAM)</li>
          <li>Cable modem PHY layers (DOCSIS)</li>
          <li>Software-defined radio research & labs</li>
          <li>High-speed modems and telemetry systems</li>
        </ul>

        <div style="margin-top:12px">
          <div class="small-title">Working ranges summary</div>
          <div class="small-muted" style="line-height:1.5">
            These are approximate nominal SNR ranges where each modulation is commonly usable for acceptable BER in many practical systems (actual required SNR depends on coding, filters and target BER):
            <ul style="margin-left:16px">
              <li><strong>4-QAM:</strong> ~8‚Äì12 dB</li>
              <li><strong>16-QAM:</strong> ~16‚Äì22 dB</li>
              <li><strong>64-QAM:</strong> ~22‚Äì28 dB</li>
              <li><strong>256-QAM:</strong> ~28‚Äì35 dB</li>
            </ul>
          </div>
        </div>

        <div style="margin-top:12px">
          <div class="small-title">Quick reference formulas</div>
          <div class="pre-block" style="font-family:monospace;">
Bits per symbol:
  b = log2(M)

SNR (linear) from dB:
  SNR_linear = 10^(SNR_dB / 10)

High‚ÄëSNR SER approximate for square M‚ÄëQAM:
  SER ‚âà 4*(1 - 1/‚àöM) * Q( sqrt( (3/(M-1)) * SNR_linear ) )

Where Q(x) is the tail probability of a standard normal distribution.
          </div>
        </div>

      </div>
    </div>
    <!-- End block diagrams excerpt -->

    <h3>4. Constellation Diagram</h3>
    <p>
      The <keyword>Constellation Diagram</keyword> is a 2D graphical representation of the possible signal states. The horizontal axis represents the In-phase component (<code>I</code>), and the vertical axis represents the Quadrature component (<code>Q</code>).
    </p>
    <ul style="margin:8px 0 0 18px;">
      <li>Each point on the grid represents a unique symbol corresponding to a specific bit pattern.</li>
      <li>To minimize the <keyword>Bit Error Rate</keyword> (BER), <keyword>Gray Coding</keyword> is typically employed so that adjacent points differ by only one bit.</li>
    </ul>
    

    <h3>5. Advantages and Disadvantages</h3>
    <p><strong>Advantages:</strong></p>
    <ul style="margin:8px 0 0 18px;">
      <li><strong>High Bandwidth Efficiency:</strong> QAM can transmit more bits per second within a given bandwidth compared to standard <keyword>BPSK</keyword> or <keyword>QPSK</keyword>.</li>
      <li><strong>Data Rate:</strong> By increasing the constellation size (<em>M</em>), the data rate can be significantly increased without increasing the signal bandwidth.</li>
      <li><strong>Noise Immunity:</strong> Compared to <keyword>Amplitude Shift Keying</keyword> (ASK) alone, QAM provides better noise immunity for the same energy per bit.</li>
    </ul>
    <p><strong>Disadvantages:</strong></p>
    <ul style="margin:8px 0 0 18px;">
      <li><strong>Sensitivity to Noise:</strong> As <em>M</em> increases, the distance between constellation points decreases, making the system more susceptible to <keyword>Additive White Gaussian Noise</keyword> (AWGN).</li>
      <li><strong>Linearity Requirements:</strong> QAM signals have a high <keyword>Peak-to-Average Power Ratio</keyword> (PAPR), requiring highly linear power amplifiers to avoid distortion.</li>
      <li><strong>Complexity:</strong> The receiver requires sophisticated <keyword>Coherent Detection</keyword> and carrier recovery circuits to maintain phase alignment.</li>
    </ul>

    <p style="margin-top:8px;">
      <em>Note:</em> For clarity and instructional purposes, this virtual laboratory uses simple binary symbol mapping. Gray coding may be explored as an extension to study its impact on BER performance.
    </p>
  </section>

  <!-- PROCEDURE -->
  <section id="procedure" class="page" role="region" aria-labelledby="procedure">
    <h2> Procedure</h2>
<ol>
  <li>Select the modulation order (M) from the control panel.</li>
  <li>Enter the number of input bits. The simulator automatically groups bits into symbols based on the selected modulation order.</li>
  <li>
For meaningful BER observation at high SNR, use a large number of bits
(e.g., ‚â•10,000).
</li>
  <li>Adjust the Signal-to-Noise Ratio (SNR) in dB to simulate different channel conditions.</li>
  <li>Set the carrier frequency and symbol rate. The symbol duration is automatically derived from the symbol rate.</li>
  <li>At high SNR, BER may appear zero for small bit counts; increase the number of bits or reduce SNR to observe errors.</li>
  <li>Click <b>Run Simulation</b> to observe the constellation diagram, time-domain waveform, and BER/SER values.</li>
  <li>Repeat the experiment by varying SNR and modulation order to study performance trade-offs.</li>
</ol>
    <p style="margin-top:8px;">
      Tips:
    </p>
    <ul style="margin:8px 0 0 18px;">
      <li>Use the constellation plot to see clustering around ideal points and to visually estimate decision regions.</li>
      <li>Lower the SNR to observe how noise spreads constellation points and causes bit errors.</li>
      <li>Compare BER/SER values across different modulation orders at the same SNR to understand the noise vs. spectral efficiency trade-off.</li>
    </ul>
  </section>

  <!-- SIMULATION -->
  <section id="simulation" class="page" role="region" aria-labelledby="simulation">
    <h2> Simulation</h2>

    <!-- Controls (re‚Äëorganized) -->
    <div class="controls-row1" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px;margin-bottom:16px;">
      <div class="input-group">
        <label for="modSelect">Modulation Order (M-QAM)</label>
        <select id="modSelect">
          <option value="4">4-QAM (QPSK)</option>
          <option value="16" selected>16-QAM</option>
          <option value="64">64-QAM</option>
          <option value="256">256-QAM</option>
        </select>
      </div>
      <div class="input-group">
        <label for="numBits">Number of Bits</label>
        <input id="numBits" type="number" min="4" max="100000" step="4" value="1024">
      </div>
      <div class="input-group">
        <label for="snr">SNR (dB): <span id="snrVal" class="slider-value">20</span></label>
        <input id="snr" type="range" min="0" max="30" step="1" value="20" style="width:100%">
      </div>
      <div class="input-group">
        <label for="amplitude">Amplitude: <span id="ampVal" class="slider-value">1.0</span> V</label>
        <input id="amplitude" type="range" min="0.5" max="5" step="0.1" value="1" style="width:100%">
      </div>
    </div>
    <div class="controls-row2" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px;margin-bottom:16px;">
      <div class="input-group">
        <label for="carrierFreq">Carrier Frequency (kHz)</label>
        <div><span id="cfVal" class="slider-value">5</span></div>
        <input id="carrierFreq" type="range" min="0.5" max="10" step="0.5" value="5" style="width:100%">
      </div>
      <div class="input-group">
        <label for="symbolRate">Symbol Duration (sec)</label>
        <div><span id="srVal" class="slider-value">2</span></div>
        <input id="symbolRate" type="range" min="0.5" max="5" step="0.5" value="2" style="width:100%">
      </div>
    </div>

    <div class="controls-row" style="margin-bottom:16px;display:flex;gap:10px;flex-wrap:wrap;align-items:center;">
    <button id="runSim" class="btn">‚ñ∂ Run Simulation</button>
    <button id="demo16QAM" class="btn" title="Generate illustrative 16-QAM waveform">16‚ÄëQAM Demo</button>
      <button id="resetBtn" class="btn" style="background:#999;">Reset</button>
      <div id="simState" style="color:#00ff88;font-weight:700;margin-left:1rem;">READY</div>
    </div>
    <div class="controls-row" style="margin-bottom:16px;display:flex;gap:20px;align-items:center;">
      <label><input id="ch1Toggle" type="checkbox" checked> CH1</label>
      <label><input id="ch2Toggle" type="checkbox" checked> CH2</label>
    </div>

    <!-- Channel Selector & Channel-Specific Controls -->
    <div style="background:#1a2540;padding:14px;border-radius:10px;border:2px solid #00ff88;margin-bottom:16px;">
      <h3 style="color:#00ff88;margin-top:0;">Channel Configuration</h3>
      
      <div style="margin-bottom:14px;display:flex;gap:10px;">
        <label style="display:flex;align-items:center;gap:6px;cursor:pointer;">
          <input id="chSelect1" type="radio" name="channelSelect" value="1" checked>
          <span style="color:#00ff88;font-weight:700;">CH1 (Input Signal)</span>
        </label>
        <label style="display:flex;align-items:center;gap:6px;cursor:pointer;">
          <input id="chSelect2" type="radio" name="channelSelect" value="2">
          <span style="color:#00eaff;font-weight:700;">CH2 (QAM Output)</span>
        </label>
      </div>

      <!-- CH1 Controls -->
      <div id="ch1Controls" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px;margin-bottom:14px;">
        <div class="input-group">
          <label for="ch1Freq">CH1 Carrier Freq (Hz):</label>
          <div><span id="ch1FreqVal" class="slider-value">1000</span></div>
          <input id="ch1Freq" type="range" min="500" max="5000" step="100" value="1000" style="width:100%;">
        </div>
        <div class="input-group">
          <label for="ch1Amp">CH1 Amplitude (V):</label>
          <div><span id="ch1AmpVal" class="slider-value">1.0</span></div>
          <input id="ch1Amp" type="range" min="0.1" max="5" step="0.1" value="1" style="width:100%;">
        </div>
        <div class="input-group">
          <label for="ch1Phase">CH1 Phase (¬∞):</label>
          <div><span id="ch1PhaseVal" class="slider-value">0</span></div>
          <input id="ch1Phase" type="range" min="0" max="360" step="15" value="0" style="width:100%;">
        </div>
      </div>

      <!-- CH2 Controls -->
      <div id="ch2Controls" style="display:none;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px;margin-bottom:14px;">
        <div class="input-group">
          <label for="ch2Offset">CH2 Amplitude Offset (V):</label>
          <div><span id="ch2OffsetVal" class="slider-value">0.0</span></div>
          <input id="ch2Offset" type="range" min="-2" max="2" step="0.1" value="0" style="width:100%;">
        </div>
        <div class="input-group">
          <label for="ch2Scale">CH2 Scale Factor:</label>
          <div><span id="ch2ScaleVal" class="slider-value">1.0</span></div>
          <input id="ch2Scale" type="range" min="0.5" max="3" step="0.1" value="1" style="width:100%;">
        </div>
      </div>
    </div>

    <div class="results" style="margin-bottom:16px;">
      <div class="card"><div class="label">Total Bits</div><div class="value" id="outTotalBits">0</div></div>
      <div class="card"><div class="label">Bits/sec</div><div class="value" id="outBitRate">0 bps</div></div>
      <div class="card"><div class="label">Symbol Rate</div><div class="value" id="outSymbolRate">0 sym/s</div></div>
      <div class="card"><div class="label">BER</div><div class="value" id="outBER">0</div></div>
      <div class="card"><div class="label">SER</div><div class="value" id="outSER">0</div></div>
    </div>

    <div class="footer-note" style="margin-bottom:16px;">
      <strong>Understanding BER (Important):</strong><br>
      BER is a statistical measure. At high SNR, errors are rare.
      With a small number of bits, BER may appear as zero even though noise is present.
      To observe meaningful BER values:
      <ul style="margin-left:16px;margin-top:6px;">
        <li>Use ‚â• 10,000 bits at moderate/high SNR</li>
        <li>Reduce SNR to clearly see errors</li>
        <li>Use higher-order QAM (16/64/256-QAM)</li>
      </ul>
    </div>

    <!-- Constellation Plot -->
    <div style="background:#050713;padding:12px;border-radius:8px;border:1px solid #00fff7;margin-bottom:14px;">
      <div style="display:flex;gap:8px;align-items:center;justify-content:space-between;flex-wrap:wrap;">
        <strong style="color:#e5e7eb;">Constellation Diagram</strong>
        <div class="legend" style="display:flex;gap:10px;">
          <div class="legend-item" style="display:flex;align-items:center;gap:4px;"><div class="legend-dot blue" style="width:12px;height:12px;border-radius:50%;background:#2196F3;"></div><div class="small" style="color:#e5e7eb;">Ideal</div></div>
          <div class="legend-item" style="display:flex;align-items:center;gap:4px;"><div class="legend-dot red" style="width:12px;height:12px;border-radius:50%;background:#f44336;"></div><div class="small" style="color:#e5e7eb;">Received</div></div>
        </div>
      </div>
      <div class="small-muted" style="margin-top:6px;color:#9aa4ff;font-size:0.85rem;">Tip: Click legend items to show/hide signal layers.</div>
      <div id="constellationPlot" style="height:360px;margin-top:8px;"></div>
    </div>

    <!-- CRO Display Container -->
    <div class="cro-container">
      <!-- CRO Header with Channel & Status -->
      <div class="cro-header">
        <div class="cro-channel-labels">
          <span id="labelCH1" class="cro-channel-label ch1-label">CH1</span>
          <span id="labelCH2" class="cro-channel-label ch2-label">CH2</span>
        </div>
        <div class="cro-status-indicators">
          <span class="status-indicator active">RUN</span>
          <span class="status-separator">‚óè</span>
          <span class="status-indicator stop-indicator">STOP</span>
        </div>
      </div>

      <!-- CRO Display Screen -->
      <div class="cro-display-wrapper">
        <!-- Grid Overlay (fixed background) -->
        <div class="cro-grid-overlay"></div>

        <!-- Real-time waveform canvas (above grid) -->
        <canvas id="waveformCanvas" class="cro-waveform-canvas"></canvas>
        
        <!-- Legacy waveform placeholder (Plotly) - kept for compatibility -->
        <canvas id="waveformCanvas" class="cro-waveform-canvas"></canvas>
      </div>

      <!-- CRO Control Labels (Display Indicators) -->
      <div class="cro-control-labels">
        <div class="cro-control-item">
          <span class="cro-control-label">TIME/DIV</span>
          <span class="cro-control-value" id="timePerDiv">0.50 ms</span>
        </div>
        <div class="cro-control-item">
          <span class="cro-control-label">VOLT/DIV</span>
          <span class="cro-control-value" id="voltPerDiv">2.00 V</span>
        </div>
        <div class="cro-control-spacer"></div>
        
        <button id="zoomAuto" class="btn" style="background:#2f3ea3;padding:6px 10px;font-size:0.85rem;">üîç Auto</button>
        <button id="zoomIn" class="btn" style="background:#2f3ea3;padding:6px 10px;font-size:0.85rem;">Z+</button>
        <button id="zoomOut" class="btn" style="background:#2f3ea3;padding:6px 10px;font-size:0.85rem;">Z‚àí</button>
        
        <label style="margin-right:10px;color:#e5e7eb;font-size:0.9rem;">
          <input id="toggleNoisy" type="checkbox" checked> Noisy
        </label>
        <button id="zoomReset" class="btn" style="background:#2f3ea3;padding:6px 10px;font-size:0.85rem;">‚Üª Reset</button>
      </div>
    </div>

    <!-- Measurements & Analysis Panel -->
    <div class="measurements-panel" style="background:#0a0e1a;border:1px solid #00fff7;border-radius:6px;padding:16px;margin:12px 0;display:grid;grid-template-columns:1fr 1fr;gap:16px;">
      <div style="border-right:1px solid rgba(0,255,247,0.2);padding-right:16px;">
        <div style="color:#00ff88;font-weight:bold;margin-bottom:8px;">üìä CH1 Input Signal</div>
        <div style="font-size:0.9rem;color:#e5e7eb;line-height:1.6;">
          <div>Frequency: <span id="ch1FreqRead">500</span> Hz</div>
          <div>Amplitude: <span id="ch1AmpRead">1.0</span> V</div>
          <div>Phase: <span id="ch1PhaseRead">0</span>¬∞</div>
          <div style="margin-top:8px;padding-top:8px;border-top:1px solid rgba(0,255,247,0.1);">
            Peak Value: <span id="ch1PeakRead">1.0</span> V
          </div>
        </div>
      </div>
      <div style="padding-left:0;">
        <div style="color:#00eaff;font-weight:bold;margin-bottom:8px;">üìà CH2 QAM Output</div>
        <div style="font-size:0.9rem;color:#e5e7eb;line-height:1.6;">
          <div>Modulation: <span id="modOrderRead">4-QAM</span></div>
          <div>Scale Factor: <span id="ch2ScaleRead">1.0</span>x</div>
          <div>DC Offset: <span id="ch2OffsetRead">0.0</span> V</div>
          <div style="margin-top:8px;padding-top:8px;border-top:1px solid rgba(0,255,247,0.1);">
            SNR: <span id="snrRead">20</span> dB
          </div>
        </div>
      </div>
    </div>

    <!-- Bit Error Visualization -->
    <div class="bit-box">
      <div class="bit-title">Bit Error Visualization (First 200 Bits)</div>
      <div class="small-muted" style="font-size:0.85rem;color:#9aa4ff;margin-bottom:6px;">Sample view for illustration; BER is computed using all transmitted bits.</div>
      <div id="bitCompare" class="bit-content"></div>
    </div>

    <!-- Details Box -->
    <div class="details-box">
      <div class="details-title">Details (For Verification &amp; Advanced Observation)</div>
      <div id="detailedInfo" class="details-content">No simulation run yet.</div>
    </div>

    <!-- Simulation-specific help (hidden until requested) -->
    <button id="simHelpBtn" class="help-btn" style="margin-top:20px;"><i class="fas fa-lightbulb"></i> HELP</button>
    <div id="simHelpContainer" class="help-container hidden">
      <div class="help-card">
        <div class="help-header">
          <h2>Simulation Help</h2>
          <span id="closeSimHelp" class="close-btn">&times;</span>
        </div>
        <p>Use the sliders above to tweak SNR, carrier frequency, symbol rate and input amplitude. Observe how changes affect constellation, time‚Äëwaveform shape, and BER/SER.</p>
        <p><strong>Example starting values:</strong> SNR‚ÄØ=‚ÄØ20‚ÄØdB, Frequency‚ÄØ=‚ÄØ2000‚ÄØHz, Symbol‚ÄØRate‚ÄØ=‚ÄØ2000‚ÄØsym/s.</p>
      </div>
    </div>

    <!-- Reference Guide for QAM Parameters & Expected Outputs -->
    <button id="refGuideBtn" class="help-btn" style="margin-top:10px;"><i class="fas fa-book"></i> QAM REFERENCE GUIDE</button>
    <div id="refGuideContainer" class="help-container hidden">
      <div class="help-card">
        <div class="help-header">
          <h2>QAM Reference Guide: Expected Waveforms & Parameters</h2>
          <span id="closeRefGuide" class="close-btn">&times;</span>
        </div>
        
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;font-size:0.95rem;">
          <!-- 4-QAM Card -->
          <div style="border:1px solid #00ff88;border-radius:4px;padding:12px;background:rgba(0,255,136,0.05);">
            <div style="color:#00ff88;font-weight:bold;margin-bottom:8px;">üìä 4-QAM (2 bits/symbol)</div>
            <div style="color:#e5e7eb;line-height:1.6;">
              <p style="margin:0 0 8px 0;"><strong>Constellation:</strong> 2√ó2 grid with points at I,Q ‚àà {¬±1}</p>
              <p style="margin:0 0 8px 0;"><strong>Typical Peak Amplitude:</strong> ‚àö2 ‚âà 1.41 V</p>
              <p style="margin:0 0 8px 0;"><strong>Test Parameters:</strong></p>
              <div style="background:rgba(0,255,247,0.1);padding:8px;margin:8px 0;border-radius:2px;font-family:monospace;font-size:0.85rem;">
                Ch1 Freq: 1000 Hz<br/>
                Ch1 Amp: 1.4 V<br/>
                Ch1 Phase: 0¬∞<br/>
                SNR: 20 dB
              </div>
            </div>
          </div>

          <!-- 16-QAM Card -->
          <div style="border:1px solid #00eaff;border-radius:4px;padding:12px;background:rgba(0,234,255,0.05);">
            <div style="color:#00eaff;font-weight:bold;margin-bottom:8px;">üìä 16-QAM (4 bits/symbol)</div>
            <div style="color:#e5e7eb;line-height:1.6;">
              <p style="margin:0 0 8px 0;"><strong>Constellation:</strong> 4√ó4 grid with points at I,Q ‚àà {¬±1, ¬±3}</p>
              <p style="margin:0 0 8px 0;"><strong>Typical Peak Amplitude:</strong> 3‚àö2 ‚âà 4.24 V</p>
              <p style="margin:0 0 8px 0;"><strong>Test Parameters:</strong></p>
              <div style="background:rgba(0,255,247,0.1);padding:8px;margin:8px 0;border-radius:2px;font-family:monospace;font-size:0.85rem;">
                Ch1 Freq: 1500 Hz<br/>
                Ch1 Amp: 4.2 V<br/>
                Ch1 Phase: 45¬∞<br/>
                SNR: 20 dB
              </div>
            </div>
          </div>

          <!-- 64-QAM Card -->
          <div style="border:1px solid #9aa4ff;border-radius:4px;padding:12px;background:rgba(154,164,255,0.05);">
            <div style="color:#9aa4ff;font-weight:bold;margin-bottom:8px;">üìä 64-QAM (6 bits/symbol)</div>
            <div style="color:#e5e7eb;line-height:1.6;">
              <p style="margin:0 0 8px 0;"><strong>Constellation:</strong> 8√ó8 grid with points at I,Q ‚àà {¬±1, ¬±3, ¬±5, ¬±7}</p>
              <p style="margin:0 0 8px 0;"><strong>Typical Peak Amplitude:</strong> 7‚àö2 ‚âà 9.90 V</p>
              <p style="margin:0 0 8px 0;"><strong>Test Parameters:</strong></p>
              <div style="background:rgba(0,255,247,0.1);padding:8px;margin:8px 0;border-radius:2px;font-family:monospace;font-size:0.85rem;">
                Ch1 Freq: 2000 Hz<br/>
                Ch1 Amp: 5.0 V (scaled)<br/>
                Ch1 Phase: 90¬∞<br/>
                SNR: 25 dB
              </div>
            </div>
          </div>

          <!-- 256-QAM Card -->
          <div style="border:1px solid #ff9aa4;border-radius:4px;padding:12px;background:rgba(255,154,164,0.05);">
            <div style="color:#ff9aa4;font-weight:bold;margin-bottom:8px;">üìä 256-QAM (8 bits/symbol)</div>
            <div style="color:#e5e7eb;line-height:1.6;">
              <p style="margin:0 0 8px 0;"><strong>Constellation:</strong> 16√ó16 grid with points at I,Q ‚àà {¬±1, ¬±3, ¬±5...¬±15}</p>
              <p style="margin:0 0 8px 0;"><strong>Typical Peak Amplitude:</strong> 15‚àö2 ‚âà 21.2 V</p>
              <p style="margin:0 0 8px 0;"><strong>Test Parameters:</strong></p>
              <div style="background:rgba(0,255,247,0.1);padding:8px;margin:8px 0;border-radius:2px;font-family:monospace;font-size:0.85rem;">
                Ch1 Freq: 2000 Hz<br/>
                Ch1 Amp: 4.0 V (scaled)<br/>
                Ch1 Phase: 180¬∞<br/>
                SNR: 30 dB
              </div>
            </div>
          </div>
        </div>

        <div style="margin-top:16px;padding:12px;background:rgba(0,255,247,0.08);border-radius:4px;border-left:3px solid #00fff7;">
          <p style="margin:0;color:#c7d2ff;font-size:0.9rem;"><strong>üí° How to Use:</strong> Copy the "Test Parameters" values into CH1 controls above, then click RUN to observe the exact constellation pattern. Use zoom in/out buttons to verify peak amplitudes and symbol spacing match expectations.</p>
        </div>
      </div>
    </div>

  </section>
<!-- PRE-TEST -->
<section id="pretest" class="page" role="region" aria-labelledby="pretest">
  <h2> Pre-Test</h2>
  <p>Answer the following questions to assess your prior knowledge of QAM concepts before starting the experiment.</p>

  <div class="quiz-form">

    <div class="quiz-q" data-answer="a">
      <p><strong>Q1.</strong> What does QAM stand for?</p>
      <label><input type="radio" name="q1" value="a"> Quadrature Amplitude Modulation</label><br>
      <label><input type="radio" name="q1" value="b"> Quantum Amplitude Measurement</label><br>
      <label><input type="radio" name="q1" value="c"> Quick Analog Modulation</label><br>
      <label><input type="radio" name="q1" value="d"> Quadratic Amplitude Module</label>
      <div class="quiz-explain">QAM stands for Quadrature Amplitude Modulation, where two carriers 90¬∞ apart are combined to carry data.</div>
    </div>

    <div class="quiz-q" data-answer="b">
      <p><strong>Q2.</strong> How many distinct symbols does 16-QAM use?</p>
      <label><input type="radio" name="q2" value="a"> 8</label><br>
      <label><input type="radio" name="q2" value="b"> 16</label><br>
      <label><input type="radio" name="q2" value="c"> 32</label><br>
      <label><input type="radio" name="q2" value="d"> 4</label>
      <div class="quiz-explain">16-QAM has 16 symbols arranged in a 4√ó4 grid on the I/Q plane.</div>
    </div>

    <div class="quiz-q" data-answer="b">
      <p><strong>Q3.</strong> How many bits per symbol does 64-QAM encode?</p>
      <label><input type="radio" name="q3" value="a"> 4</label><br>
      <label><input type="radio" name="q3" value="b"> 6</label><br>
      <label><input type="radio" name="q3" value="c"> 8</label><br>
      <label><input type="radio" name="q3" value="d"> 2</label>
      <div class="quiz-explain">log‚ÇÇ(64) = 6 bits per symbol.</div>
    </div>

    <div class="quiz-q" data-answer="b">
      <p><strong>Q4.</strong> What do I and Q represent in QAM?</p>
      <label><input type="radio" name="q4" value="a"> Input and Quality</label><br>
      <label><input type="radio" name="q4" value="b"> In-phase and Quadrature</label><br>
      <label><input type="radio" name="q4" value="c"> Impedance and Quantum</label><br>
      <label><input type="radio" name="q4" value="d"> Integer and Quotient</label>
      <div class="quiz-explain">I = In-phase component, Q = Quadrature component. They are orthogonal (90¬∞ apart).</div>
    </div>

    <div class="quiz-q" data-answer="b">
      <p><strong>Q5.</strong> What is the primary advantage of QAM over simpler modulation schemes?</p>
      <label><input type="radio" name="q5" value="a"> Lower cost hardware</label><br>
      <label><input type="radio" name="q5" value="b"> Higher spectral efficiency</label><br>
      <label><input type="radio" name="q5" value="c"> Longer range</label><br>
      <label><input type="radio" name="q5" value="d"> Simpler implementation</label>
      <div class="quiz-explain">QAM can encode more bits per symbol than simpler schemes, improving spectral efficiency.</div>
    </div>


    <button type="button" class="btn" onclick="submitPretest()" style="margin-top:12px;">Submit Pre-Test</button>
  </div>

</section>

<!-- POST-TEST -->
<section id="posttest" class="page">
  <h2> Post-Test (Performance & Analysis)</h2>

  <form id="posttestForm" class="quiz-form">

    <!-- Q1 -->
    <div class="quiz-q" data-answer="c">
      <p><strong>Q1.</strong> What happens to the constellation when SNR decreases?</p>
      <label><input type="radio" name="pq1" value="a"> Points move farther apart</label><br>
      <label><input type="radio" name="pq1" value="b"> Points cluster tightly</label><br>
      <label><input type="radio" name="pq1" value="c"> Points spread and overlap</label><br>
      <label><input type="radio" name="pq1" value="d"> Number of symbols increases</label>

      <div class="quiz-explain">
        Lower SNR increases noise power, causing constellation points to scatter and overlap.
      </div>
    </div>

    <!-- Q2 -->
    <div class="quiz-q" data-answer="b">
      <p><strong>Q2.</strong> Which modulation has the highest noise immunity?</p>
      <label><input type="radio" name="pq2" value="a"> 256-QAM</label><br>
      <label><input type="radio" name="pq2" value="b"> 4-QAM</label><br>
      <label><input type="radio" name="pq2" value="c"> 64-QAM</label><br>
      <label><input type="radio" name="pq2" value="d"> 128-QAM</label>

      <div class="quiz-explain">
        Lower-order QAM has larger symbol spacing, making it more robust to noise.
      </div>
    </div>

    <!-- Q3 -->
    <div class="quiz-q" data-answer="a">
      <p><strong>Q3.</strong> What mainly causes bit errors in AWGN channels?</p>
      <label><input type="radio" name="pq3" value="a"> Noise added to I/Q components</label><br>
      <label><input type="radio" name="pq3" value="b"> Symbol rate increase</label><br>
      <label><input type="radio" name="pq3" value="c"> Carrier frequency drift</label><br>
      <label><input type="radio" name="pq3" value="d"> Sampling resolution</label>

      <div class="quiz-explain">
        AWGN perturbs I and Q amplitudes, leading to incorrect symbol decisions.
      </div>
    </div>

    <!-- Q4 -->
    <div class="quiz-q" data-answer="d">
      <p><strong>Q4.</strong> Which parameter directly improves BER performance?</p>
      <label><input type="radio" name="pq4" value="a"> Increasing M</label><br>
      <label><input type="radio" name="pq4" value="b"> Increasing symbol rate</label><br>
      <label><input type="radio" name="pq4" value="c"> Increasing bandwidth</label><br>
      <label><input type="radio" name="pq4" value="d"> Increasing SNR</label>

      <div class="quiz-explain">
        Higher SNR improves the reliability of symbol detection.
      </div>
    </div>

    <!-- Q5 -->
    <div class="quiz-q" data-answer="a">
      <p><strong>Q5.</strong> The formula for bits per symbol in M-QAM is:</p>
      <label><input type="radio" name="pq5" value="a"> k = log‚ÇÇ(M)</label><br>
      <label><input type="radio" name="pq5" value="b"> k = M / 2</label><br>
      <label><input type="radio" name="pq5" value="c"> k = ‚àöM</label><br>
      <label><input type="radio" name="pq5" value="d"> k = M¬≤</label>
      <div class="quiz-explain">k = log‚ÇÇ(M). For example, in 16-QAM: k = 4 bits/symbol.</div>
    </div>

    <button type="button" class="btn" onclick="submitPosttest()">Submit Post-Test</button>
  </form>


</section>

<!-- RESULTS & SUMMARY -->
<section id="results" class="page" role="region" aria-labelledby="results">
  <h2> Results</h2>
  <div id="overallResults" class="quiz-result"></div>
  <h3>What We Did in This Virtual Lab</h3>
  <ul>
    <li>Explored QAM theory and mathematical formulation.</li>
    <li>Visualized various M‚ÄëQAM constellation diagrams.</li>
    <li>Added AWGN noise and studied BER/SER effects.</li>
    <li>Performed pre‚Äëtest and post‚Äëtest to reinforce learning.</li>
  </ul>
</section>







</div>

<!-- ===== Project Footer ===== -->
<footer style="margin-top:40px;background:#0f172a;color:#e5e7eb;padding:24px 16px;text-align:center;font-family:'Segoe UI',Arial,sans-serif;">
  <h3 style="margin-bottom:8px;color:#38bdf8;">QAM Virtual Laboratory</h3>
  <p style="margin:6px 0;font-weight:600;">Department of Electronics and Communication Engineering</p>
  <hr style="max-width:600px;margin:16px auto;border:0;border-top:1px solid #334155;">
  <p style="margin-top:16px;font-size:0.9rem;color:#3abbea;">¬© 2026 Puducherry Technological University</p>
</footer>
<!-- ===== End Footer ===== -->

<script>
/* ---- Utility & Simulation Engine ---- */
document.addEventListener('DOMContentLoaded', () => {
  // Elements
  const navBtns = document.querySelectorAll('.nav-btn');
  const pages = document.querySelectorAll('.page');
  navBtns.forEach(btn => btn.addEventListener('click', () => {
    navBtns.forEach(b=>b.classList.remove('active'));
    pages.forEach(p=>p.classList.remove('active'));
    btn.classList.add('active');
    const targetPage = document.getElementById(btn.dataset.page);
    targetPage.classList.add('active');

    // if simulation tab becomes visible, update canvas size
    if (btn.dataset.page === 'simulation') {
      resizeWaveformCanvas();
    }

    // reset any scrolling so each section starts at top
    window.scrollTo({ top: 0, behavior: 'smooth' });
    document.body.scrollTop = 0;       // for Safari
    document.documentElement.scrollTop = 0; // for other browsers
    const container = document.querySelector('.container');
    if (container) container.scrollTop = 0;
  }));

  // Controls
  const modSelect = document.getElementById('modSelect');
  const numBitsEl = document.getElementById('numBits');
  const snrEl = document.getElementById('snr');
  const snrVal = document.getElementById('snrVal');
  const amplitude = document.getElementById('amplitude');
  const ampVal = document.getElementById('ampVal');
  const carrierFreq = document.getElementById('carrierFreq');
  const symbolRate = document.getElementById('symbolRate');
  const runBtn = document.getElementById('runSim');
  const resetBtn = document.getElementById('resetBtn');
  const toggleNoisy = document.getElementById('toggleNoisy');
  const zoomReset = document.getElementById('zoomReset');
  const zoomAuto = document.getElementById('zoomAuto');
  const zoomIn = document.getElementById('zoomIn');
  const zoomOut = document.getElementById('zoomOut');

  // Outputs
  const outTotalBits = document.getElementById('outTotalBits');
  const outBitRate = document.getElementById('outBitRate');
  const outSymbolRate = document.getElementById('outSymbolRate');
  const outBER = document.getElementById('outBER');
  const outSER = document.getElementById('outSER');
  const bitCompare = document.getElementById('bitCompare');
  const detailedInfo = document.getElementById('detailedInfo');

  // Plots
  const constellationDiv = document.getElementById('constellationPlot');
  const waveformDiv = document.getElementById('waveformPlot');

  // Plotly initial blank states
  const PLOTLY_DARK_THEME = {
  paper_bgcolor: '#050713',
  plot_bgcolor: '#050713',
  font: {
    color: '#e5e7eb',
    size: 13
  },
  xaxis: {
    titlefont: { color: '#00fff7' },
    tickfont: { color: '#cbd5e1' },
    gridcolor: 'rgba(255,255,255,0.08)',
    zerolinecolor: 'rgba(255,255,255,0.3)'
  },
  yaxis: {
    titlefont: { color: '#00fff7' },
    tickfont: { color: '#cbd5e1' },
    gridcolor: 'rgba(255,255,255,0.08)',
    zerolinecolor: 'rgba(255,255,255,0.3)'
  },
  legend: {
    font: { color: '#e5e7eb' }
  }
};

  Plotly.newPlot(
  constellationDiv,
  [{ x:[], y:[], mode:'markers' }],
  {
    ...PLOTLY_DARK_THEME,
    title: { text:'Constellation Diagram', font:{color:'#00fff7'} }
  },
  { responsive:true }
);

 Plotly.newPlot(
  waveformDiv,
  [{ x:[], y:[], mode:'lines' }],
  {
    ...PLOTLY_DARK_THEME,
    title: { text:'Time-domain QAM waveform', font:{color:'#00fff7'} }
  },
  { responsive:true }
);

  // setup real-time waveform canvas and animation
  const waveformCanvas = document.getElementById('waveformCanvas');
  if (waveformDiv) waveformDiv.style.display = 'none';  // hide legacy plot
  let wfCtx = null;
  let waveformRunning = false; // start stopped until user clicks run
  
  // channel visibility flags
  let showCH1 = true;
  let showCH2 = true;
  
  // waveform data storage for CH2
  let lastCleanWave = null;
  
  // zoom and pan state
  let zoomScale = 1.0; // 1 = normal, >1 = zoomed in, <1 = zoomed out
  let panX = 0; // horizontal pan offset
  let panY = 0; // vertical pan offset
  let autoScaleEnabled = true;
  const MIN_ZOOM = 0.5;
  const MAX_ZOOM = 4.0;

  function resizeWaveformCanvas() {
    if (waveformCanvas) {
      waveformCanvas.width = waveformCanvas.clientWidth;
      waveformCanvas.height = waveformCanvas.clientHeight;
      if (!wfCtx) wfCtx = waveformCanvas.getContext('2d');
    }
  }
  window.addEventListener('resize', resizeWaveformCanvas);
  resizeWaveformCanvas();

  // channel toggle listeners
  const ch1Toggle = document.getElementById('ch1Toggle');
  const ch2Toggle = document.getElementById('ch2Toggle');
  const labelCH1 = document.getElementById('labelCH1');
  const labelCH2 = document.getElementById('labelCH2');
  if (ch1Toggle && labelCH1) {
    ch1Toggle.addEventListener('change', () => {
      showCH1 = ch1Toggle.checked;
      labelCH1.classList.toggle('inactive', !showCH1);
    });
  }
  if (ch2Toggle && labelCH2) {
    ch2Toggle.addEventListener('change', () => {
      showCH2 = ch2Toggle.checked;
      labelCH2.classList.toggle('inactive', !showCH2);
    });
  }

  // ===== CHANNEL SELECTOR & PARAMETER CONTROLS =====
  let selectedChannel = '1'; // default to CH1
  
  // Get channel control elements
  const chSelect1 = document.getElementById('chSelect1');
  const chSelect2 = document.getElementById('chSelect2');
  const ch1Controls = document.getElementById('ch1Controls');
  const ch2Controls = document.getElementById('ch2Controls');
  
  // CH1 parameters
  const ch1Freq = document.getElementById('ch1Freq');
  const ch1FreqVal = document.getElementById('ch1FreqVal');
  const ch1Amp = document.getElementById('ch1Amp');
  const ch1AmpVal = document.getElementById('ch1AmpVal');
  const ch1Phase = document.getElementById('ch1Phase');
  const ch1PhaseVal = document.getElementById('ch1PhaseVal');
  
  // CH2 parameters
  const ch2Offset = document.getElementById('ch2Offset');
  const ch2OffsetVal = document.getElementById('ch2OffsetVal');
  const ch2Scale = document.getElementById('ch2Scale');
  const ch2ScaleVal = document.getElementById('ch2ScaleVal');
  
  // Channel selector: show/hide controls based on selection
  if (chSelect1 && chSelect2) {
    chSelect1.addEventListener('change', () => {
      if (chSelect1.checked) {
        selectedChannel = '1';
        ch1Controls.style.display = 'grid';
        ch2Controls.style.display = 'none';
        // highlight CH1 in CRO header
        if (labelCH1 && labelCH2) {
          labelCH1.style.opacity = '1';
          labelCH1.style.fontWeight = '900';
          labelCH2.style.opacity = '0.5';
          labelCH2.style.fontWeight = '700';
        }
      }
    });
    chSelect2.addEventListener('change', () => {
      if (chSelect2.checked) {
        selectedChannel = '2';
        ch1Controls.style.display = 'none';
        ch2Controls.style.display = 'grid';
        // highlight CH2 in CRO header
        if (labelCH1 && labelCH2) {
          labelCH2.style.opacity = '1';
          labelCH2.style.fontWeight = '900';
          labelCH1.style.opacity = '0.5';
          labelCH1.style.fontWeight = '700';
        }
      }
    });
    // Set initial state
    labelCH1.style.opacity = '1';
    labelCH1.style.fontWeight = '900';
    labelCH2.style.opacity = '0.5';
    labelCH2.style.fontWeight = '700';
  }
  
  // CH1 parameter listeners
  if (ch1Freq) {
    ch1Freq.addEventListener('input', () => {
      let v = Number(ch1Freq.value);
      if (v < 500) v = 500;
      if (v > 5000) v = 5000;
      ch1Freq.value = v;
      ch1FreqVal.textContent = v;
      document.getElementById('ch1FreqRead').textContent = v;
      const pct = ((v - 500) / (5000 - 500)) * 100;
      ch1Freq.style.backgroundSize = pct + '% 100%';
    });
  }
  if (ch1Amp) {
    ch1Amp.addEventListener('input', () => {
      let v = Number(ch1Amp.value);
      if (v < 0.1) v = 0.1;
      if (v > 5) v = 5;
      ch1Amp.value = v;
      ch1AmpVal.textContent = v.toFixed(1);
      document.getElementById('ch1AmpRead').textContent = v.toFixed(1);
      document.getElementById('ch1PeakRead').textContent = v.toFixed(1);
      const pct = ((v - 0.1) / (5 - 0.1)) * 100;
      ch1Amp.style.backgroundSize = pct + '% 100%';
    });
  }
  if (ch1Phase) {
    ch1Phase.addEventListener('input', () => {
      let v = Number(ch1Phase.value);
      if (v < 0) v = 0;
      if (v > 360) v = 360;
      ch1Phase.value = v;
      ch1PhaseVal.textContent = v;
      document.getElementById('ch1PhaseRead').textContent = v;
      const pct = (v / 360) * 100;
      ch1Phase.style.backgroundSize = pct + '% 100%';
    });
  }
  
  // CH2 parameter listeners
  if (ch2Offset) {
    ch2Offset.addEventListener('input', () => {
      let v = Number(ch2Offset.value);
      if (v < -2) v = -2;
      if (v > 2) v = 2;
      ch2Offset.value = v;
      ch2OffsetVal.textContent = v.toFixed(1);
      document.getElementById('ch2OffsetRead').textContent = v.toFixed(1);
      const pct = ((v - (-2)) / (2 - (-2))) * 100;
      ch2Offset.style.backgroundSize = pct + '% 100%';
    });
  }
  if (ch2Scale) {
    ch2Scale.addEventListener('input', () => {
      let v = Number(ch2Scale.value);
      if (v < 0.5) v = 0.5;
      if (v > 3) v = 3;
      ch2Scale.value = v;
      ch2ScaleVal.textContent = v.toFixed(1);
      document.getElementById('ch2ScaleRead').textContent = v.toFixed(1);
      const pct = ((v - 0.5) / (3 - 0.5)) * 100;
      ch2Scale.style.backgroundSize = pct + '% 100%';
    });
  }

  // store numeric display values for scaling
  // (SimulationEngine is a const defined earlier) ‚Äî add properties directly
  SimulationEngine.timePerDiv = 5; // default ms
  SimulationEngine.voltPerDiv = 2; // default V

  // Initialize measurement displays with default values
  document.getElementById('ch1FreqRead').textContent = ch1Freq ? Number(ch1Freq.value) : '1000';
  document.getElementById('ch1AmpRead').textContent = ch1Amp ? Number(ch1Amp.value).toFixed(1) : '1.0';
  document.getElementById('ch1PhaseRead').textContent = ch1Phase ? Number(ch1Phase.value) : '0';
  document.getElementById('ch1PeakRead').textContent = ch1Amp ? Number(ch1Amp.value).toFixed(1) : '1.0';
  document.getElementById('ch2OffsetRead').textContent = ch2Offset ? Number(ch2Offset.value).toFixed(1) : '0.0';
  document.getElementById('ch2ScaleRead').textContent = ch2Scale ? Number(ch2Scale.value).toFixed(1) : '1.0';
  document.getElementById('modOrderRead').textContent = (Number(modSelect.value) || 4) + '-QAM';
  document.getElementById('snrRead').textContent = Number(snrEl.value) || '20';

  // Global 16-QAM symbol sequence and oscilloscope time
  let globalOSCTime = 0;
  let qam16Symbols = []; // will hold {I, Q} for each symbol in sequence

  // Generate a sequence of 16-QAM symbols (all 16 constellation points in repeating cycle)
  function generate16QAMSymbolSequence() {
    const points = [];
    // 16-QAM constellation: I, Q ‚àà {¬±1, ¬±3}
    for (let q of [-3, -1, 1, 3]) {
      for (let i of [-3, -1, 1, 3]) {
        points.push({ I: i, Q: q });
      }
    }
    // Repeat approximately 5 times for a longer animation loop
    qam16Symbols = [];
    for (let rep = 0; rep < 5; rep++) {
      for (let p of points) {
        qam16Symbols.push(p);
      }
    }
  }
  generate16QAMSymbolSequence(); // initialize on startup

  // Global oscilloscope draw loop
  function drawOscilloscope(timestamp) {
    if (!wfCtx) return;
    // check for resize if container size changed
    if (waveformCanvas.width !== waveformCanvas.clientWidth || waveformCanvas.height !== waveformCanvas.clientHeight) {
      resizeWaveformCanvas();
    }

    if (waveformRunning) {
      // clear fully to keep traces stable and avoid ghosting/jitter
      wfCtx.fillStyle = '#050713';
      wfCtx.fillRect(0, 0, waveformCanvas.width, waveformCanvas.height);

      // Channel positioning: CH1 upper half, CH2 lower half
      const quarterH = waveformCanvas.height / 4;
      const yBaseCH1 = quarterH;           // center of upper half
      const yBaseCH2 = quarterH * 3;       // center of lower half
      const pixelScale = 120; // pixels per unit time for smooth scaling

      // common line styling
      wfCtx.lineWidth = 2;
      wfCtx.lineJoin = 'round';
      wfCtx.lineCap = 'round';

      // CH1: clean input sinusoid with adjustable input frequency (in Hz)
      if (showCH1) {
        wfCtx.strokeStyle = '#00ff88'; // neon green
        wfCtx.shadowColor = 'rgba(0,255,136,0.6)';
        wfCtx.shadowBlur = 4;
        wfCtx.beginPath();
        const f_input = Number(ch1Freq.value); // Hz
        const amp_ch1 = Number(ch1Amp.value);
        const phase_ch1 = Number(ch1Phase.value) * Math.PI / 180;
        for (let x = 0; x < waveformCanvas.width; x++) {
          const t = globalOSCTime + x / pixelScale;
          const y1 = amp_ch1 * Math.sin(2 * Math.PI * f_input * t + phase_ch1);
          const yPx = yBaseCH1 - y1 * 50;
          if (x === 0) wfCtx.moveTo(x, yPx);
          else wfCtx.lineTo(x, yPx);
        }
        wfCtx.stroke();
        // label CH1 at left
        wfCtx.shadowBlur = 0;
        wfCtx.fillStyle = '#00ff88';
        wfCtx.font = Math.max(12, Math.round(waveformCanvas.height * 0.03)) + 'px sans-serif';
        wfCtx.fillText('CH1: Input (' + f_input.toFixed(2) + ' Hz)', 6, yBaseCH1 - 8);
      }

      // CH2: 16-QAM waveform with carrier modulation
      if (showCH2 && qam16Symbols.length > 0) {
        wfCtx.strokeStyle = '#00eaff'; // cyan/blue
        wfCtx.shadowColor = 'rgba(0,234,255,0.6)';
        wfCtx.shadowBlur = 4;
        wfCtx.beginPath();
        
        const fc_kHz = Number(carrierFreq.value); // kHz
        const fc = fc_kHz * 1000; // convert to Hz for modulation
        const symbolDur = Number(symbolRate.value); // symbol duration in seconds
        
        for (let x = 0; x < waveformCanvas.width; x++) {
          const t = globalOSCTime + x / pixelScale;
          
          // Determine which symbol we're in and progress within that symbol
          const symbolIndex = Math.floor(t / symbolDur) % qam16Symbols.length;
          const timeInSymbol = (t % symbolDur) / symbolDur; // 0 to 1
          const symbol = qam16Symbols[symbolIndex];
          
          // Smooth transition between symbol (amplitude ramping)
          // Use a windowed approach to make transitions visible but smooth
          let ampAtTime = 1.0;
          if (timeInSymbol < 0.1) {
            // ramp in
            ampAtTime = timeInSymbol / 0.1;
          } else if (timeInSymbol > 0.9) {
            // ramp out
            ampAtTime = (1 - timeInSymbol) / 0.1;
          }
          
          // 16-QAM modulation: s(t) = amplitude * [I*cos(2œÄfc*t) - Q*sin(2œÄfc*t)]
          const I = symbol.I;
          const Q = symbol.Q;
          const modSig = I * Math.cos(2 * Math.PI * fc * t) - Q * Math.sin(2 * Math.PI * fc * t);
          const y2 = ampAtTime * modSig * (1 / Math.sqrt(10)); // normalize for display
          const y2Px = yBaseCH2 - y2 * 50;
          
          if (x === 0) wfCtx.moveTo(x, y2Px);
          else wfCtx.lineTo(x, y2Px);
        }
        wfCtx.stroke();
        // label CH2 at left
        wfCtx.shadowBlur = 0;
        wfCtx.fillStyle = '#00eaff';
        wfCtx.font = Math.max(12, Math.round(waveformCanvas.height * 0.03)) + 'px sans-serif';
        wfCtx.fillText('CH2: 16-QAM (' + fc_kHz.toFixed(1) + ' kHz)', 6, yBaseCH2 - 8);
      }

      // reset shadow
      wfCtx.shadowBlur = 0;
      wfCtx.shadowColor = 'transparent';

      // advance time smoothly for steady observation
      globalOSCTime += 0.02;
    }
    requestAnimationFrame(drawOscilloscope);
  }
  requestAnimationFrame(drawOscilloscope);

  // run/stop toggling via status indicators
  // declare variables in outer scope so reset handler can access them
  let runIndicator = document.querySelector('.status-indicator.active');
  let stopIndicator = document.querySelectorAll('.status-indicator')[1];
  if (runIndicator && stopIndicator) {
    runIndicator.addEventListener('click', () => {
      waveformRunning = true;
      lastFrameTime = performance.now();
      runIndicator.classList.add('active');
      stopIndicator.classList.remove('active');
      document.getElementById('simState').textContent = 'RUNNING';
    });
    stopIndicator.addEventListener('click', () => {
      waveformRunning = false;
      stopIndicator.classList.add('active');
      runIndicator.classList.remove('active');
      document.getElementById('simState').textContent = 'READY';
    });

    // start in stopped state
    runIndicator.classList.remove('active');
    stopIndicator.classList.add('active');
    document.getElementById('simState').textContent = 'READY';
  }

  // update SNR label and enforce bounds
  function simulate() {
    runBtn.click();
  }

  // Update CRO display indicators (Time/Div, Volt/Div)
  function updateCRODisplayIndicators() {
    const symbolRateVal = Number(symbolRate.value);
    const snrVal = Number(snrEl.value);
    const ampValNum = amplitude ? Number(amplitude.value) : 1;
    
    // Time/Div calculation: based on symbol duration and zoom level
    const timePerSymbolMs = 1000 / symbolRateVal;
    let timePerDiv = timePerSymbolMs / 4;
    timePerDiv = timePerDiv / zoomScale; // zoom in = smaller time per division = more detail
    const timePerDivStr = timePerDiv < 0.1 
      ? (timePerDiv * 1000).toFixed(2) + ' ¬µs' 
      : timePerDiv.toFixed(2) + ' ms';
    
    document.getElementById('timePerDiv').textContent = timePerDivStr;
    SimulationEngine.timePerDiv = timePerDiv;
    
    // Volt/Div calculation: incorporate amplitude, noise level, and zoom
    const baseVoltPerDiv = ampValNum || 1.0;
    const snrFactor = Math.max(0.5, 3 - (snrVal / 15));
    let voltPerDiv = baseVoltPerDiv * snrFactor;
    voltPerDiv = voltPerDiv / zoomScale; // zoom in = smaller voltage per division = more detail
    
    document.getElementById('voltPerDiv').textContent = voltPerDiv.toFixed(2) + ' V';
    SimulationEngine.voltPerDiv = voltPerDiv;
  }

  snrEl.addEventListener('input', () => {
    let v = Number(snrEl.value);
    if (v < 0) v = 0;
    if (v > 30) v = 30;
    snrEl.value = v;
    snrVal.textContent = v;
    document.getElementById('snrRead').textContent = v;
    // update track fill
    const pct = ((v - 0) / (30 - 0)) * 100;
    snrEl.style.backgroundSize = pct + '% 100%';
    updateCRODisplayIndicators();
    if (!waveformRunning) document.getElementById('simState').textContent = 'READY';
    // update constellation in real-time if simulation data exists
    if (lastCleanWave) {
      const M = Number(modSelect.value);
      const cfg = getConfig(M);
      const constellation = generateConstellationPoints(M);
      const symbolIndices = bitsToSymbolIndices(randomBits(cfg.bitsPerSymbol * 16), cfg.bitsPerSymbol);
      const txIQ = symbolsToIQ(symbolIndices, constellation);
      const rxIQ = addAWGNtoSymbols(txIQ, v);
      plotConstellation(constellation, txIQ, rxIQ);
    }
  });

  // Update constellation when modulation changes
  modSelect.addEventListener('change', () => {
    const modValue = Number(modSelect.value);
    document.getElementById('modOrderRead').textContent = modValue + '-QAM';
    if (!waveformRunning) document.getElementById('simState').textContent = 'READY';
    if (lastCleanWave) {
      const M = modValue;
      const cfg = getConfig(M);
      const constellation = generateConstellationPoints(M);
      const snr = Number(snrEl.value);
      const symbolIndices = bitsToSymbolIndices(randomBits(cfg.bitsPerSymbol * 16), cfg.bitsPerSymbol);
      const txIQ = symbolsToIQ(symbolIndices, constellation);
      const rxIQ = addAWGNtoSymbols(txIQ, snr);
      plotConstellation(constellation, txIQ, rxIQ);
    }
  });

  // amplitude slider updates
  if (amplitude) {
    amplitude.addEventListener('input', () => {
      let v = Number(amplitude.value);
      if (v < 0.5) v = 0.5;
      if (v > 5) v = 5;
      amplitude.value = v;
      if (ampVal) ampVal.textContent = v.toFixed(1);
      // update fill
      const pct = ((v - 0.5) / (5 - 0.5)) * 100;
      amplitude.style.backgroundSize = pct + '% 100%';
      updateCRODisplayIndicators();
      if (!waveformRunning) document.getElementById('simState').textContent = 'READY';
    });
  }

  // new slider value displays with live update and bounds enforcement
  const cfVal = document.getElementById('cfVal');
  const srVal = document.getElementById('srVal');

  carrierFreq.addEventListener('input', () => {
    let v = Number(carrierFreq.value);
    if (v < 0.5) v = 0.5;
    if (v > 10) v = 10;
    carrierFreq.value = v;
    cfVal.textContent = v.toFixed(1);
    const pct = ((v - 0.5) / (10 - 0.5)) * 100;
    carrierFreq.style.backgroundSize = pct + '% 100%';
    if (!waveformRunning) document.getElementById('simState').textContent = 'READY';
  });

  symbolRate.addEventListener('input', () => {
    let v = Number(symbolRate.value);
    if (v < 0.5) v = 0.5;
    if (v > 5) v = 5;
    symbolRate.value = v;
    srVal.textContent = v.toFixed(1);
    const pct = ((v - 0.5) / (5 - 0.5)) * 100;
    symbolRate.style.backgroundSize = pct + '% 100%';
    updateCRODisplayIndicators();
    if (!waveformRunning) document.getElementById('simState').textContent = 'READY';
  });

  // help toggling for simulation-specific help
  const simHelpBtn = document.getElementById('simHelpBtn');
  const simHelpContainer = document.getElementById('simHelpContainer');
  const closeSimHelp = document.getElementById('closeSimHelp');
  if (simHelpBtn && simHelpContainer && closeSimHelp) {
    simHelpBtn.addEventListener('click', () => {
      simHelpContainer.classList.remove('hidden');
      simHelpContainer.scrollIntoView({ behavior: 'smooth' });
    });
    closeSimHelp.addEventListener('click', () => {
      simHelpContainer.classList.add('hidden');
    });
    simHelpContainer.addEventListener('click', e => {
      if (e.target === simHelpContainer) simHelpContainer.classList.add('hidden');
    });
  }

  // Reference guide toggle
  const refGuideBtn = document.getElementById('refGuideBtn');
  const refGuideContainer = document.getElementById('refGuideContainer');
  const closeRefGuide = document.getElementById('closeRefGuide');
  if (refGuideBtn && refGuideContainer && closeRefGuide) {
    refGuideBtn.addEventListener('click', () => {
      refGuideContainer.classList.remove('hidden');
      refGuideContainer.scrollIntoView({ behavior: 'smooth' });
    });
    closeRefGuide.addEventListener('click', () => {
      refGuideContainer.classList.add('hidden');
    });
    refGuideContainer.addEventListener('click', e => {
      if (e.target === refGuideContainer) refGuideContainer.classList.add('hidden');
    });
  }

  // show/hide symbol input area

  // QAM config helper
  function getConfig(M) {
    const bps = Math.round(Math.log2(M));
    return {M, bitsPerSymbol:bps, sqrtM:Math.sqrt(M)};
  }

  // Build constellation mapping row-major (I left->right, Q bottom->top)
  function generateConstellationPoints(M) {
    const sqrtM = Math.sqrt(M);
    const points = [];
    // For even sqrtM, levels: -(sqrtM-1), -(sqrtM-3), ..., (sqrtM-1)
    const levels = [];
    for(let k=0;k<sqrtM;k++){
      levels.push(2*k - (sqrtM-1));
    }
    // Map index: row-major (Q rows then I columns)
    for(let q=0;q<sqrtM;q++){
      for(let i=0;i<sqrtM;i++){
        // I = levels[i], Q = levels[q]
        points.push({I:levels[i], Q:levels[q]});
      }
    }
    return points;
  }

  // Bits -> symbol indices (MSB first in chunk)
  function bitsToSymbolIndices(bits, bitsPerSymbol) {
    const syms = [];
    for(let i=0;i<bits.length;i+=bitsPerSymbol){
      const chunk = bits.slice(i,i+bitsPerSymbol);
      if(chunk.length < bitsPerSymbol) break;
      const idx = parseInt(chunk.join(''),2);
      syms.push(idx);
    }
    return syms;
  }

  // Random bits
  function randomBits(n){ return Array.from({length:n},()=>Math.random()<0.5?0:1);}

  // Build mapped symbol complex values
  function symbolsToIQ(symbolIndices, constellation) {
    return symbolIndices.map(idx => {
      const p = constellation[idx];
      return {I:p.I, Q:p.Q, idx};
    });
  }

  // Add AWGN to complex symbols
  function addAWGNtoSymbols(symbolsIQ, snrDb) {
    if(symbolsIQ.length===0) return [];
    // compute average signal power per dimension
    const sigPower = symbolsIQ.reduce((s,x)=>s + x.I*x.I + x.Q*x.Q,0)/symbolsIQ.length;
    const snrLinear = Math.pow(10, snrDb/10);
    const noisePower = sigPower / snrLinear;
    const noiseStd = Math.sqrt(noisePower/2);
    return symbolsIQ.map(s => {
      // gaussian using Box-Muller
      function gauss(){ let u=0,v=0; while(u===0)u=Math.random(); while(v===0)v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }
      return {I: s.I + gauss()*noiseStd, Q: s.Q + gauss()*noiseStd};
    });
  }

  // Nearest-neighbor demap
  function demapSymbols(rxIQ, constellation) {
    const rxIdx = [];
    rxIQ.forEach(p => {
      let minD = Infinity, minIdx=0;
      for(let i=0;i<constellation.length;i++){
        const d =
  (p.I - constellation[i].I) ** 2 +
  (p.Q - constellation[i].Q) ** 2;
        if(d<minD){minD=d;minIdx=i;}
      }
      rxIdx.push(minIdx);
    });
    return rxIdx;
  }

  // symbol indices -> bits (per symbol bitsPerSymbol)
  function symbolIndicesToBits(indices, bitsPerSymbol) {
    const bits=[];
    indices.forEach(i=>{
      const s = i.toString(2).padStart(bitsPerSymbol,'0');
      s.split('').forEach(ch=>bits.push(Number(ch)));
    });
    return bits;
  }

  // Time-domain modulated waveform generator
  function generateWaveform(IQSymbols, fc, symbolDurMs, samplesPerSymbol=64) {
    // samplesPerSymbol chosen to keep plots smooth; can be adjusted based on symbolDur and fc
    const Ts = symbolDurMs/1000; // symbol duration seconds
    const fs = samplesPerSymbol / Ts; // sampling frequency
    const dt = 1/fs;
    const t = [];
    const y = [];
    let time=0;
    for(let k=0;k<IQSymbols.length;k++){
      const I = IQSymbols[k].I;
      const Q = IQSymbols[k].Q;
      for(let n=0;n<samplesPerSymbol;n++){
        t.push(time);
        // s(t) = I*cos(2œÄfct) - Q*sin(2œÄfct)  (conventional)
        y.push( I*Math.cos(2*Math.PI*fc*time) - Q*Math.sin(2*Math.PI*fc*time) );
        time += dt;
      }
    }
    return {t,y,fs};
  }

  // Plot constellation
  function plotConstellation(constellation, txPoints, rxPoints) {
    const idealTrace = {x: constellation.map(p=>p.I), y: constellation.map(p=>p.Q),
      mode:'markers', type:'scatter', name:'Ideal (symbols)', marker:{color:'#2196F3',size:12}};
    const txTrace = {x: txPoints.map(p=>p.I), y: txPoints.map(p=>p.Q),
      mode:'markers', type:'scatter', name:'Transmitted (no noise)', marker:{color:'#0d47a1',size:8,opacity:0.9}};
    const rxTrace = {x: rxPoints.map(p=>p.I), y: rxPoints.map(p=>p.Q),
      mode:'markers', type:'scatter', name:'Received (noisy)', marker:{color:'#f44336',size:6,opacity:0.6}};
    const layout = {
...PLOTLY_DARK_THEME,
  title: {
    text: 'Constellation Diagram',
    font: { color: '#00fff7', size: 18 }
  },
  xaxis: {
    ...PLOTLY_DARK_THEME.xaxis,
    title: 'In-phase (I)',
    zeroline: true,
    showgrid: true
  },
  yaxis: {
    ...PLOTLY_DARK_THEME.yaxis,
    title: 'Quadrature (Q)',
    zeroline: true,
    showgrid: true
  },
  hovermode: 'closest',
  height: 380
};
    const cfg = {responsive:true, scrollZoom:true, displayModeBar:true};
    Plotly.react(constellationDiv, [idealTrace, txTrace, rxTrace], layout, cfg);
  }

  // Plot waveform (clean + noisy overlay)
  function plotWaveform(cleanWave, noisyWave) {
    const ampScale = amplitude ? Number(amplitude.value) : 1;
    const scaledCleanY = cleanWave.y.map(v => v * ampScale);
    const cleanTrace = {x: cleanWave.t, y: scaledCleanY, mode:'lines', name:'Clean QAM waveform', line:{width:1, color:'#00ff88'}};
    const traces = [cleanTrace];
    if(toggleNoisy.checked && noisyWave){
      const scaledNoisyY = noisyWave.y.map(v => v * ampScale);
      traces.push({x: noisyWave.t, y: scaledNoisyY, mode:'lines', name:'Noisy waveform', line:{width:1, dash:'dot', color:'#00eaff'}});
    }
    const layout = {
  ...PLOTLY_DARK_THEME,
  title: {
    text: 'Time-domain QAM waveform',
    font: { color: '#00fff7', size: 18 }
  },
  xaxis: {
    ...PLOTLY_DARK_THEME.xaxis,
    title: 'Time (s)'
  },
  yaxis: {
    ...PLOTLY_DARK_THEME.yaxis,
    title: 'Amplitude'
  },
  height: 360
};

    const cfg = {responsive:true, scrollZoom:true, displayModeBar:true};
    Plotly.react(waveformDiv, traces, layout, cfg);
  }

  // AUTO-scale: reset oscilloscope time and regenerate QAM symbols for fresh view
  function autoScaleCRO() {
    // Reset oscilloscope time for fresh sweep
    globalOSCTime = 0;
    
    // Regenerate 16-QAM symbol sequence
    generate16QAMSymbolSequence();
    
    // Update CRO display indicators
    autoScaleEnabled = true;
    updateCRODisplayIndicators();

    // ensure canvas is visible and animation running
    resizeWaveformCanvas();
    waveformRunning = true;
    if (runIndicator && stopIndicator) { runIndicator.classList.add('active'); stopIndicator.classList.remove('active'); }
    document.getElementById('simState').textContent = 'RUNNING';
  }

  // Generate a demonstrative 16-QAM waveform with visible carrier,
  // discrete envelope steps (quantized to 4 levels), envelope changes
  // from I/Q modulation, and phase discontinuities at symbol boundaries.
  function generate16QAMDemo(opts = {}) {
    const fc = Number(opts.fc || carrierFreq.value || 2000);
    const symbolRateVal = Number(opts.symbolRate || symbolRate.value || 2000);
    const samplesPerSymbol = opts.samplesPerSymbol || 128; // keep carrier visible
    const Nsym = opts.nsymbols || 80;

    const M = 16;
    const cfg = getConfig(M);
    const constellation = generateConstellationPoints(M);

    // Build a deterministic repeating sequence of symbol indices for a clean, stable waveform
    const symbolIndices = Array.from({length: Nsym}, (_,k) => k % M);
    const txIQ = symbolsToIQ(symbolIndices, constellation);

    // Compute raw magnitudes and quantize envelope into 4 discrete levels
    const mags = txIQ.map(s => Math.sqrt(s.I * s.I + s.Q * s.Q));
    const minR = Math.min(...mags);
    const maxR = Math.max(...mags);
    const scaleFactors = [0.6, 0.95, 1.4, 1.9]; // visually distinct envelope steps

    // Sampling parameters
    const Ts = 1 / symbolRateVal; // seconds per symbol
    const fs = samplesPerSymbol / Ts;
    const dt = 1 / fs;

    const t = [];
    const y = [];
    let globalTime = 0;

    // To produce phase discontinuities, each symbol's carrier phase is restarted (tau from 0)
    for (let k = 0; k < txIQ.length; k++) {
      const I = txIQ[k].I;
      const Q = txIQ[k].Q;
      const r = Math.sqrt(I * I + Q * Q);
      // quantize normalized magnitude into 4 buckets
      const norm = (r - minR) / (maxR - minR + 1e-12);
      let idx = Math.floor(norm * 4);
      if (idx < 0) idx = 0; if (idx > 3) idx = 3;
      const ampStep = scaleFactors[idx];

      // Optional small symbol-to-symbol phase jump for extra 'busyness'
      const phaseJump = (k % 3 === 0) ? Math.PI * 0.25 : 0; // deterministic jumps every 3rd symbol

      for (let n = 0; n < samplesPerSymbol; n++) {
        const tau = n * dt; // local time inside symbol -> restarts at 0 producing discontinuity
        // s(t) = A*(I*cos(2œÄfœÑ + œÜ_jump) - Q*sin(2œÄfœÑ + œÜ_jump))
        const carrierArg = 2 * Math.PI * fc * tau + phaseJump;
        const sample = ampStep * (I * Math.cos(carrierArg) - Q * Math.sin(carrierArg));
        t.push(globalTime);
        y.push(sample);
        globalTime += dt;
      }
    }

    // Package waveform with sampling frequency for canvas plotting
    const wave = { t: t, y: y, fs: fs };
    lastCleanWave = wave;

    // Also prepare constellation traces for visual reference (no noise)
    const txIQFull = txIQ; // transmitted IQ points
    const rxIQ = txIQFull.slice(); // noise-free receive points

    // Update UI and plots (noise-free)
    plotConstellation(constellation, txIQFull, rxIQ);
    plotWaveform(wave, null);

    // Start canvas animation if not running so canvas shows the demo
    waveformRunning = true;
    document.getElementById('simState').textContent = 'RUNNING';
    if (runIndicator && stopIndicator) { runIndicator.classList.add('active'); stopIndicator.classList.remove('active'); }

    return wave;
  }

  // Wire demo button
  const demoBtn = document.getElementById('demo16QAM');
  if (demoBtn) {
    demoBtn.addEventListener('click', () => {
      // set modulation selector to 16 for consistency
      modSelect.value = '16';
      document.getElementById('modOrderRead').textContent = '16-QAM';
      generate16QAMDemo({ fc: Number(carrierFreq.value), symbolRate: Number(symbolRate.value), samplesPerSymbol: 128, nsymbols: 100 });
    });
  }

  // Main simulation runner
  runBtn.addEventListener('click', ()=> {
    // ensure canvas is sized correctly (might have been hidden earlier)
    resizeWaveformCanvas();
    // start waveform if not already running
    waveformRunning = true;
    globalOSCTime = 0; // reset oscilloscope time
    // update RUN/STOP indicator buttons
    if (runIndicator && stopIndicator) {
      runIndicator.classList.add('active');
      stopIndicator.classList.remove('active');
    }
    document.getElementById('simState').textContent = 'RUNNING';

    const M = Number(modSelect.value);
    const cfg = getConfig(M);
    const constellation = generateConstellationPoints(M);

    // Input mode

    let symbolIndices = [];
    let txBits = [];
    let desiredCount = Number(numBitsEl.value);

// BIT-BASED INPUT ONLY (symbol-based removed as per lab design)
const bitsPerSymbol = cfg.bitsPerSymbol;
let desiredBits = Math.max(bitsPerSymbol, desiredCount);

// ensure multiple of bits-per-symbol
const remainder = desiredBits % bitsPerSymbol;
if (remainder !== 0) {
  desiredBits = desiredBits - remainder;
}

txBits = randomBits(desiredBits);
symbolIndices = bitsToSymbolIndices(txBits, bitsPerSymbol);
    // Prepare transmitted IQ
    const txIQ = symbolsToIQ(symbolIndices, constellation);

    // Add noise
    const snr = Number(snrEl.value);
    const rxIQ = addAWGNtoSymbols(txIQ, snr);

    // Demap
    const rxIndices = demapSymbols(rxIQ, constellation);
    const rxBits = symbolIndicesToBits(rxIndices, cfg.bitsPerSymbol);

    // Errors
    const totalBits = Math.min(txBits.length, rxBits.length);
    let bitErrors=0;
    for(let i=0;i<totalBits;i++) if(txBits[i]!==rxBits[i]) bitErrors++;
    // symbol errors
    let symErrors=0;
    for(let i=0;i<symbolIndices.length;i++) if(symbolIndices[i] !== rxIndices[i]) symErrors++;

    const BER = (bitErrors/totalBits) || 0;
    const SER = (symErrors/symbolIndices.length) || 0;
    const bitRate = Number(symbolRate.value) * cfg.bitsPerSymbol; // bits per second based on user symbol rate input
    const symbolRateVal = Number(symbolRate.value);

// ================= Time-domain waveforms =================
const samplesPerSymbol = 60; // visualization only
const symbolDurations = 1000 / Number(symbolRate.value);
const maxSymbolsForWave = Math.min(100, txIQ.length);

const cleanWave = generateWaveform(
  txIQ.slice(0, maxSymbolsForWave),
  Number(carrierFreq.value),
  symbolDurations,
  samplesPerSymbol
);

// save waveform for channel 2 plotting later
lastCleanWave = cleanWave;

document.getElementById('simState').textContent = 'RUNNING';

const noisyWave = generateWaveform(
  rxIQ.slice(0, maxSymbolsForWave),
  Number(carrierFreq.value),
  symbolDurations,
  samplesPerSymbol
);
    // update UI results
    outTotalBits.textContent = totalBits;
   outBitRate.textContent = bitRate.toLocaleString() + ' bps';
    outSymbolRate.textContent = symbolRateVal.toLocaleString() + ' sym/s';
    outBER.textContent = BER.toExponential(3);
    outSER.textContent = SER.toExponential(3);

    // bit compare
    const maxDisplay = 200;
    const displayBits = Math.min(maxDisplay, totalBits);
    const txSample = txBits.slice(0, displayBits).join('');
    const rxSample = rxBits.slice(0, displayBits).join('');
    // highlight mismatches by wrapping with <mark>- but we use plaintext; show mismatches as uppercase/lowercase or with markers
    let compText = '';
    for(let i=0;i<displayBits;i++){
      compText += (txBits[i]===rxBits[i]) ? txBits[i] : ('['+rxBits[i]+']');
    }
    let rxHtml = '';
for (let i = 0; i < displayBits; i++) {
  if (txBits[i] === rxBits[i]) {
    rxHtml += rxBits[i];
  } else {
    rxHtml += `<span class="bit-error">${rxBits[i]}</span>`;
  }
}

bitCompare.innerHTML = `
<strong>TX:</strong> ${txBits.slice(0, displayBits).join('')}
<br><strong>RX:</strong> ${rxHtml}
<br><span class="bit-note">Mismatched bits are highlighted to illustrate how noise causes bit errors.</span>
`;



    // detailed info
    detailedInfo.textContent = `
M = ${M} (${cfg.bitsPerSymbol} bits/symbol)

Transmission Summary:
‚Ä¢ Total symbols transmitted: ${symbolIndices.length}
‚Ä¢ Total bits compared: ${totalBits}

Error Statistics:
‚Ä¢ Bit errors: ${bitErrors}
‚Ä¢ Symbol errors: ${symErrors}

Error Rates:
‚Ä¢ BER (Bit Error Rate): ${BER}
‚Ä¢ SER (Symbol Error Rate): ${SER}

Channel & Timing:
‚Ä¢ SNR: ${snr} dB
‚Ä¢ Symbol duration: ${(1000 / Number(symbolRate.value)).toFixed(3)} ms
    `.trim();

    // Plot constellation & waveform
    // For traces: ideal constellation points, transmitted points, received noisy points
    plotConstellation(constellation, txIQ, rxIQ);
    plotWaveform(cleanWave, noisyWave);

    // zoom auto handler (calls auto-scale routine that fits waveform)
    zoomAuto.onclick = autoScaleCRO;

    // zoom in handler
    zoomIn.onclick = () => {
      zoomScale = Math.min(MAX_ZOOM, zoomScale * 1.5);
      autoScaleEnabled = false;
      updateCRODisplayIndicators();
    };

    // zoom out handler
    zoomOut.onclick = () => {
      zoomScale = Math.max(MIN_ZOOM, zoomScale / 1.5);
      autoScaleEnabled = false;
      updateCRODisplayIndicators();
    };

    // zoom reset binds
    zoomReset.onclick = ()=> {
      zoomScale = 1.0;
      panX = 0;
      panY = 0;
      autoScaleEnabled = true;
      updateCRODisplayIndicators();
      Plotly.relayout(waveformDiv, {
        'xaxis.autorange': true,
        'yaxis.autorange': true
      });
      Plotly.relayout(constellationDiv, {'xaxis.autorange': true,'yaxis.autorange': true});
    };
  }); // runBtn

  // Reset
 resetBtn.addEventListener('click', ()=> {
  modSelect.value = '4';
  numBitsEl.value = 1024;
  snrEl.value = 20; 
  snrVal.textContent = '20';
  amplitude.value = 1;
  if (ampVal) ampVal.textContent = '1.0';
  carrierFreq.value = 5;
  symbolRate.value = 2;
  cfVal.textContent = '5';
  srVal.textContent = '2';
  bitCompare.innerHTML = '';
  detailedInfo.textContent = 'No simulation run yet.';

  // reset slider fills (adjust for new kHz and symbol duration ranges)
  snrEl.style.backgroundSize = ((snrEl.value - 0)/(30-0))*100 + '% 100%';
  amplitude.style.backgroundSize = ((amplitude.value - 0.5)/(5-0.5))*100 + '% 100%';
  carrierFreq.style.backgroundSize = ((carrierFreq.value - 0.5)/(10-0.5))*100 + '% 100%';
  symbolRate.style.backgroundSize = ((symbolRate.value - 0.5)/(5-0.5))*100 + '% 100%';

  // regenerate fresh 16-QAM symbols
  generate16QAMSymbolSequence();
  globalOSCTime = 0;

  Plotly.react(constellationDiv, [{x:[],y:[],mode:'markers'}],
    {...PLOTLY_DARK_THEME, title:{text:'Constellation Diagram',font:{color:'#00fff7'}}});

  Plotly.react(waveformDiv, [{x:[],y:[],mode:'lines'}],
    {...PLOTLY_DARK_THEME, title:{text:'Time-domain QAM waveform',font:{color:'#00fff7'}}});

  // update CRO display indicators
  updateCRODisplayIndicators();

  // reset waveform and stop running
  globalOSCTime = 0;
  waveformRunning = false;
  if (runIndicator && stopIndicator) {
    runIndicator.classList.remove('active');
    stopIndicator.classList.add('active');
  }
  document.getElementById('simState').textContent = 'READY';

  // ensure UI is consistent after reset (user may click Run when ready)
});

  // toggle noisy: replot waveform to show/hide
  toggleNoisy.addEventListener('change', ()=> {
    // Re-run waveform plotting if last run exists; easiest: click Run again for precise overlay
    // But attempt to reuse last plotted arrays (Plotly.data)
    // For reliability, instruct user to re-run simulation; we'll also try to toggle overlay if possible
    try {
      const gd = waveformDiv;
      if(!gd.data || gd.data.length===0) return;
      // if there's a second trace (noisy), hide/show by update
      if(gd.data.length>1){
        const update = {visible: toggleNoisy.checked ? true : 'legendonly'};
        Plotly.restyle(gd, update, [1]);
      }
    } catch(e){}
  });

  // initial UI values
  snrVal.textContent = snrEl.value;
  if (ampVal) ampVal.textContent = amplitude.value;
  if (cfVal) cfVal.textContent = '5';
  if (srVal) srVal.textContent = '2';
  // set initial slider fill (adjust for new kHz and symbol duration ranges)
  snrEl.style.backgroundSize = ((snrEl.value - 0)/(30-0))*100 + '% 100%';
  amplitude.style.backgroundSize = ((amplitude.value - 0.5)/(5-0.5))*100 + '% 100%';
  carrierFreq.style.backgroundSize = ((carrierFreq.value - 0.5)/(10-0.5))*100 + '% 100%';
  symbolRate.style.backgroundSize = ((symbolRate.value - 0.5)/(5-0.5))*100 + '% 100%';
  // initialize CRO display indicators
  updateCRODisplayIndicators();
}); // DOMContentLoaded end
</script>
<!-- ===== PRE-TEST QUIZ LOGIC ===== -->
<script>
function submitPretest() {
  const questions = document.querySelectorAll("#pretest .quiz-q");
  let score = 0;

  for (let q of questions) {
    const correct = q.dataset.answer;
    const selected = q.querySelector("input[type=radio]:checked");

    if (!selected) {
      alert("Please answer ALL questions before submitting.");
      return;
    }

    const labels = q.querySelectorAll("label");

    labels.forEach(label => {
      const input = label.querySelector("input");
      label.classList.remove("correct", "wrong");

      if (input.value === correct) {
        label.classList.add("correct");
      } else if (input.checked && input.value !== correct) {
        label.classList.add("wrong");
      }
    });

    if (selected.value === correct) score++;

    q.querySelector(".quiz-explain").style.display = "block";
  }

  // update overall results container
  const overall = document.getElementById("overallResults");
  if (overall) {
    overall.innerHTML = `<p><strong>Pre-Test Score:</strong> ${score} / ${questions.length}</p>` + overall.innerHTML;
  }
}
</script>
<script>
function submitPosttest() {
  const questions = document.querySelectorAll('#posttestForm .quiz-q');
  let score = 0;

  for (const q of questions) {
    const correct = q.dataset.answer;
    const selected = q.querySelector('input:checked');

    if (!selected) {
      alert("Please answer all questions before submitting.");
      return;
    }

    const options = q.querySelectorAll('label');
    options.forEach(label => {
      const input = label.querySelector('input');
      label.classList.remove('correct', 'wrong');

      if (input.value === correct) {
        label.classList.add('correct');
      }
      if (selected.value === input.value && input.value !== correct) {
        label.classList.add('wrong');
      }
    });

    if (selected.value === correct) score++;
    q.classList.add('answered');

  }

  const overall2 = document.getElementById('overallResults');
  if (overall2) {
    overall2.innerHTML = (overall2.innerHTML || '') + `<p><strong>Post-Test Score:</strong> ${score} / ${questions.length}</p>`;
  }
}
</script>


</body>
</html>